<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini RPG — JavaScript Canvas</title>
  <style>
    :root{--bg:#0b1220;--panel:#0f1724;--accent:#8bd3c7;--muted:#9fb0c6}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:var(--muted);background:linear-gradient(180deg,#071022,#071833);}
    .wrap{max-width:1100px;margin:18px auto;padding:12px;display:grid;grid-template-columns:1fr 320px;gap:14px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;padding:12px;box-shadow:0 6px 22px rgba(0,0,0,0.6)}
    canvas{width:100%;height:600px;border-radius:8px;background:#071122;display:block}
    h1{color:white;margin:6px 0 12px;font-size:18px}
    .muted{color:var(--muted);font-size:13px}
    button{appearance:none;border:0;padding:8px 12px;border-radius:8px;background:var(--accent);color:#053;cursor:pointer}
    .kbd{background:#0c1726;border-radius:6px;padding:6px 8px;color:#cbd5e1;font-weight:600}
    @media(max-width:980px){.wrap{grid-template-columns:1fr;}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div style="display:flex;align-items:center;justify-content:space-between">
        <h1>Mini RPG</h1>
        <div class="muted">Top-down demo: explore, fight, collect.</div>
      </div>

      <canvas id="game" width="800" height="600"></canvas>

      <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
        <button id="btnStart">Start / Restart</button>
        <div style="margin-left:auto" class="muted">Controls: <span class="kbd">WASD / Arrows</span> — <span class="kbd">Space</span> interact/attack</div>
      </div>
    </div>

    <div class="card">
      <div style="display:flex;gap:10px;align-items:center;margin-bottom:8px">
        <div style="width:64px;height:64px;border-radius:8px;background:linear-gradient(90deg,var(--accent),#7ee787);display:flex;align-items:center;justify-content:center;color:#042; font-weight:800;font-size:20px">RPG</div>
        <div>
          <div style="font-weight:700;color:white">Mini RPG</div>
          <div class="muted">Simple, extendable demo with map, enemies, inventory and quests.</div>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03)" />

      <div style="font-weight:700;color:white;margin-bottom:6px">Player</div>
      <div style="display:flex;justify-content:space-between"><div>HP</div><div id="hp">20</div></div>
      <div style="display:flex;justify-content:space-between"><div>Level</div><div id="level">1</div></div>
      <div style="display:flex;justify-content:space-between"><div>XP</div><div id="xp">0</div></div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03)" />

      <div style="font-weight:700;color:white;margin-bottom:6px">Inventory</div>
      <div id="inventory" class="muted">Empty</div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03)" />

      <div style="font-weight:700;color:white;margin-bottom:6px">Quest</div>
      <div id="quest" class="muted">None</div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03)" />

      <div class="muted" style="font-size:13px;margin-top:8px">This is a single-file HTML — open locally to play. You can request: more levels, procedural maps, dialogues, save slots, sound, or visuals.</div>
    </div>
  </div>

  <script>
  // Mini RPG — single-file vanilla JS
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // UI
  const hpEl = document.getElementById('hp');
  const lvlEl = document.getElementById('level');
  const xpEl = document.getElementById('xp');
  const invEl = document.getElementById('inventory');
  const questEl = document.getElementById('quest');
  const btnStart = document.getElementById('btnStart');

  // Game state
  let running = false; let lastTime = 0; let dtAccum = 0;
  const TILE = 32; const MAP_W = 25, MAP_H = 18;

  const keys = {};
  window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.key === ' '){ e.preventDefault(); }});
  window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

  // Player
  const player = { x: Math.floor(MAP_W/2), y: Math.floor(MAP_H/2), px:0, py:0, hp:20, maxHp:20, level:1, xp:0, atk:4 };
  const inventory = [];
  let currentQuest = null;

  // Map tiles: 0 grass, 1 wall, 2 tree, 3 water, 4 town
  let map = [];
  const entities = []; // enemies, items, NPCs

  function makeMap(){ map = []; for(let y=0;y<MAP_H;y++){ const row=[]; for(let x=0;x<MAP_W;x++){ let t = 0; if(x===0||y===0||x===MAP_W-1||y===MAP_H-1) t=1; else if(Math.random()<0.06) t=2; else if(Math.random()<0.03) t=3; row.push(t);} map.push(row);} // place a town
    map[2][2]=4; map[2][3]=4; map[3][2]=4; map[3][3]=4;
}

  function spawnEntities(){ entities.length=0; // enemies
    for(let i=0;i<12;i++){ let x,y; do{ x = Math.floor(Math.random()*MAP_W); y = Math.floor(Math.random()*MAP_H);} while(blocked(x,y) || (Math.abs(x-player.x)<3 && Math.abs(y-player.y)<3)); entities.push({type:'goblin',x,y,hp:8,atk:3}); }
    // NPC in town
    entities.push({type:'npc',x:3,y:3,name:'Elder'});
    // item
    entities.push({type:'item',x:5,y:5,name:'Health Potion'});
}

  function blocked(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return true; const t = map[y][x]; return t===1||t===2||t===3; }

  function startGame(){ makeMap(); player.x = Math.floor(MAP_W/2); player.y = Math.floor(MAP_H/2); player.hp = player.maxHp; player.level = 1; player.xp = 0; inventory.length=0; currentQuest = null; spawnEntities(); running=true; lastTime = performance.now(); requestAnimationFrame(loop); updateUI(); }
  btnStart.addEventListener('click', ()=>{ startGame(); });

  function loop(ts){ if(!running) return; const dt = Math.min(0.05, (ts-lastTime)/1000); lastTime = ts; update(dt); draw(); requestAnimationFrame(loop); }

  // Movement & Interaction
  let moveCooldown = 0;
  function update(dt){ moveCooldown -= dt; if(moveCooldown<=0){ let dx=0,dy=0; if(keys['arrowup']||keys['w']) dy=-1; else if(keys['arrowdown']||keys['s']) dy=1; if(keys['arrowleft']||keys['a']) dx=-1; else if(keys['arrowright']||keys['d']) dx=1; if(dx!==0||dy!==0){ tryMove(dx,dy); moveCooldown = 0.12; }}
    // attack/interact
    if(keys[' ']){ handleAction(); keys[' '] = false; }
    // simple enemy AI: move towards player sometimes
    for(const e of entities){ if(e.type==='goblin'){ if(Math.random()<0.02){ const sx = Math.sign(player.x - e.x); const sy = Math.sign(player.y - e.y); if(!blocked(e.x+sx,e.y+sy) && !entityAt(e.x+sx,e.y+sy)) { e.x += sx; e.y += sy; } } // if on player -> attack
        if(e.x===player.x && e.y===player.y){ player.hp -= e.atk; addMessage('Goblin hits you for '+e.atk); if(player.hp<=0){ addMessage('You died! Restart to play again.'); running=false; } updateUI(); }
    }}
  }

  function tryMove(dx,dy){ const nx = player.x+dx, ny = player.y+dy; if(blocked(nx,ny)) { addMessage('You bump into an obstacle.'); return; } const ent = entityAt(nx,ny); if(ent){ addMessage('You interact with '+(ent.name||ent.type)); if(ent.type==='goblin'){ // attack
        attackEntity(ent);
      } else if(ent.type==='item'){ pickItem(ent); } else if(ent.type==='npc'){ talkToNPC(ent); } return; } player.x = nx; player.y = ny; }

  function entityAt(x,y){ return entities.find(e=>e.x===x && e.y===y); }

  function attackEntity(ent){ // simple turn: player hits then enemy
    const dmg = Math.max(1, player.atk + Math.floor(Math.random()*3) - 1);
    ent.hp -= dmg; addMessage('You hit the '+ent.type+' for '+dmg);
    if(ent.hp<=0){ addMessage('You defeated the '+ent.type+'!'); const idx = entities.indexOf(ent); if(idx>=0) entities.splice(idx,1); gainXP(6); // drop loot sometimes
        if(Math.random()<0.4){ entities.push({type:'item',x:ent.x,y:ent.y,name:'Gold Coin'}); }
    } else { // enemy retaliates
      const edmg = Math.max(1, ent.atk + Math.floor(Math.random()*2)-1); player.hp -= edmg; addMessage(ent.type+' hits you for '+edmg); if(player.hp<=0){ addMessage('You died!'); running=false; } }
    updateUI(); }

  function pickItem(it){ addMessage('You picked up: '+it.name); inventory.push(it.name); const idx = entities.indexOf(it); if(idx>=0) entities.splice(idx,1); updateUI(); }

  function talkToNPC(npc){ addMessage(npc.name+': "Brave one, the goblins disturb our fields. Bring me a Gold Coin."'); currentQuest = {type:'bring',target:'Gold Coin',giver:npc.name,completed:false}; updateUI(); }

  function handleAction(){ // if item at tile -> pick, if enemy -> attack
    const ent = entityAt(player.x,player.y); if(ent){ if(ent.type==='item') pickItem(ent); else if(ent.type==='goblin') attackEntity(ent); else if(ent.type==='npc') talkToNPC(ent); return; }
    // else check nearby NPC for quest completion
    if(currentQuest && currentQuest.type==='bring'){ const idx = inventory.indexOf(currentQuest.target); if(idx>=0){ inventory.splice(idx,1); currentQuest.completed = true; addMessage('Quest complete! You gave '+currentQuest.target+' to '+currentQuest.giver); gainXP(20); updateUI(); } else addMessage('You have nothing to give.'); }
  }

  function gainXP(n){ player.xp += n; addMessage('Gained '+n+' XP'); while(player.xp >= player.level*20){ player.xp -= player.level*20; player.level++; player.maxHp += 4; player.atk += 1; player.hp = player.maxHp; addMessage('Leveled up! Now level '+player.level); } updateUI(); }

  // Messaging log (console-like)
  const messages = [];
  function addMessage(s){ messages.unshift(s); if(messages.length>8) messages.pop(); }

  function updateUI(){ hpEl.textContent = player.hp + ' / ' + player.maxHp; lvlEl.textContent = player.level; xpEl.textContent = player.xp + ' / ' + (player.level*20); invEl.textContent = inventory.length? inventory.join(', '):'Empty'; questEl.textContent = currentQuest? (currentQuest.completed? 'Completed: ' + currentQuest.target : currentQuest.giver + ' — Bring: ' + currentQuest.target) : 'None'; }

  // Drawing
  function draw(){ // clear
    ctx.fillStyle = '#071122'; ctx.fillRect(0,0,W,H);
    // draw map tiles
    for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++){
      const t = map[y][x]; const sx = x*TILE, sy = y*TILE;
      if(t===0){ ctx.fillStyle='#0b3b17'; ctx.fillRect(sx,sy,TILE,TILE); }
      else if(t===1){ ctx.fillStyle='#3b3b3b'; ctx.fillRect(sx,sy,TILE,TILE); }
      else if(t===2){ ctx.fillStyle='#12502a'; ctx.fillRect(sx,sy,TILE,TILE); ctx.fillStyle='#0b2b12'; ctx.fillRect(sx+6,sy+6,20,20); }
      else if(t===3){ ctx.fillStyle='#153a5b'; ctx.fillRect(sx,sy,TILE,TILE); }
      else if(t===4){ ctx.fillStyle='#6b4a1f'; ctx.fillRect(sx,sy,TILE,TILE); ctx.fillStyle='#d9c8a4'; ctx.fillRect(sx+6,sy+6,20,20); }
      // grid
      ctx.strokeStyle='rgba(0,0,0,0.05)'; ctx.strokeRect(sx,sy,TILE,TILE);
    }
    // entities
    for(const e of entities){ const ex = e.x*TILE + TILE/2, ey = e.y*TILE + TILE/2;
      if(e.type==='goblin'){ ctx.fillStyle='#8a2e2e'; ctx.beginPath(); ctx.arc(ex,ey,12,0,Math.PI*2); ctx.fill(); ctx.fillStyle='white'; ctx.font='10px monospace'; ctx.textAlign='center'; ctx.fillText('G',ex,ey+3); }
      else if(e.type==='item'){ ctx.fillStyle='#e7d34a'; ctx.fillRect(e.x*TILE+10,e.y*TILE+10,12,12); ctx.fillStyle='black'; ctx.font='10px monospace'; ctx.textAlign='center'; ctx.fillText('I',ex,ey+3); }
      else if(e.type==='npc'){ ctx.fillStyle='#2a6b8a'; ctx.fillRect(e.x*TILE+6,e.y*TILE+6,20,20); ctx.fillStyle='white'; ctx.font='10px monospace'; ctx.textAlign='center'; ctx.fillText('E',ex,ey+8); }
    }
    // player
    const px = player.x*TILE + TILE/2, py = player.y*TILE + TILE/2;
    ctx.fillStyle='#8bd3c7'; ctx.beginPath(); ctx.moveTo(px,py-12); ctx.lineTo(px-10,py+10); ctx.lineTo(px+10,py+10); ctx.closePath(); ctx.fill();

    // HUD messages
    ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(8,8,260,110);
    ctx.fillStyle='white'; ctx.font='12px monospace'; ctx.textAlign='left'; let my=26; for(const m of messages){ ctx.fillText(m,16,my); my+=14; }
  }

  // auto-start a demo map so user sees something
  makeMap(); spawnEntities(); addMessage('Welcome — press Start to (re)start the adventure.'); updateUI(); draw();
  </script>
</body>
</html>
